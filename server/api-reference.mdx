---
sidebar_label: API Reference
---

import SchemaGeneralRaw from '!!raw-loader!../sdk/vircadia-world-sdk-ts/schema/schema.general.ts';
import ClientCoreRaw from '!!raw-loader!../sdk/vircadia-world-sdk-ts/module/client/core/vircadia.client.core.ts';
import * as SchemaGeneral from '../sdk/vircadia-world-sdk-ts/schema/schema.general';

# Vircadia World API Reference

This document provides a comprehensive reference for the Vircadia World API endpoints and communication protocols. This documentation uses raw loaders to ensure the code snippets always reflect the latest implementation.

## Communication Constants

The following constants define the base paths for API communication:

```typescript
// From Communication namespace in schema.general.ts
export const WS_UPGRADE_PATH = "/world/ws";
export const REST_BASE_PATH = "/world/rest";
```

## REST API

The REST API is accessible at the base path defined by `REST_BASE_PATH` (`/world/rest`).

### Available Endpoints

<table>
  <thead>
    <tr>
      <th>Endpoint</th>
      <th>Method</th>
      <th>Path</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    {Object.keys(SchemaGeneral.Communication.REST.E_Endpoint).map(key => {
      const endpointKey = SchemaGeneral.Communication.REST.E_Endpoint[key];
      const endpoint = SchemaGeneral.Communication.REST.Endpoint[endpointKey];
      return (
        <>
          <tr key={key}>
            <td><code>{key}</code></td>
            <td><code>{endpoint.method}</code></td>
            <td><code>{endpoint.path}</code></td>
            <td>{endpoint.description}</td>
          </tr>
          <tr>
            <td colSpan={4}>
              <details>
                <summary>Parameters</summary>
                <table>
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Required</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    {endpoint.parameters.map(param => (
                      <tr key={param.name}>
                        <td><code>{param.name}</code></td>
                        <td><code>{param.type}</code></td>
                        <td>{param.required ? 'Yes' : 'No'}</td>
                        <td>{param.description}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </details>
            </td>
          </tr>
          <tr>
            <td colSpan={4}>
              <details>
                <summary>Returns</summary>
                <p><strong>Type:</strong> <code>{endpoint.returns.type}</code></p>
                <p><strong>Description:</strong> {endpoint.returns.description}</p>
                {endpoint.returns.fields && (
                  <>
                    <h4>Fields</h4>
                    <table>
                      <thead>
                        <tr>
                          <th>Name</th>
                          <th>Type</th>
                          <th>Description</th>
                        </tr>
                      </thead>
                      <tbody>
                        {endpoint.returns.fields.map(field => (
                          <tr key={field.name}>
                            <td><code>{field.name}</code></td>
                            <td><code>{field.type}</code></td>
                            <td>{field.description}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </>
                )}
              </details>
            </td>
          </tr>
        </>
      );
    })}
  </tbody>
</table>

### SDK Implementation Example

The Vircadia SDK provides a client implementation for authenticating with the server:

```typescript
// From ConnectionManager.connect in vircadia.client.core.ts
async connect(options?: { timeoutMs?: number }): Promise<ConnectionInfo> {
    // If already connected, return immediately
    if (this.isClientConnected()) {
        return this.getConnectionInfo();
    }

    // If connection is in progress, return the existing promise
    if (this.connectionPromise && this.isConnecting()) {
        return this.connectionPromise;
    }

    // Create new connection promise
    this.connectionPromise = (async () => {
        try {
            this.updateConnectionStatus("connecting");

            const url = new URL(this.config.serverUrl);
            url.searchParams.set("token", this.config.authToken);
            url.searchParams.set("provider", this.config.authProvider);

            this.ws = new WebSocket(url);
            this.ws.onmessage = this.handleMessage.bind(this);
            this.ws.onclose = this.handleClose.bind(this);
            this.ws.onerror = this.handleError.bind(this);

            // Connection handling code...
        } catch (error) {
            // Error handling...
        }
    })();

    return this.connectionPromise;
}
```

## WebSocket API

WebSocket connections are established by upgrading a connection at `WS_UPGRADE_PATH` (`/world/ws`).

### Establish Connection

The WebSocket connection is established by creating a connection with search parameters:

```typescript title="TypeScript WS upgrade example"
// Format for WebSocket connection URL
const url = new URL(`https://server-domain${Communication.WS_UPGRADE_PATH}`);
url.searchParams.set("token", authToken);    // Authentication token
url.searchParams.set("provider", authProvider);  // Authentication provider name
const ws = new WebSocket(url);
```

Required URL parameters:
- `token`: Authentication token obtained from the authentication provider
- `provider`: Name of the authentication provider (e.g., 'system', 'local')

These parameters are validated against the server using the `Communication.REST.Endpoint.AUTH_SESSION_VALIDATE` endpoint internally during the connection process.

### Message Types

The following message types are available in the WebSocket API:

<table>
  <thead>
    <tr>
      <th>Message Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    {Object.keys(SchemaGeneral.Communication.WebSocket.MessageType).map(key => {
      const msgType = SchemaGeneral.Communication.WebSocket.MessageType[key];
      const doc = SchemaGeneral.Communication.WebSocket.MessageTypeDocs[msgType];
      return (
        <>
          <tr key={key}>
            <td><code>{key}</code></td>
            <td>{doc.description}</td>
          </tr>
          {doc.parameters && (
            <tr>
              <td colSpan={2}>
                <details>
                  <summary>Parameters</summary>
                  <table>
                    <thead>
                      <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Required</th>
                        <th>Description</th>
                      </tr>
                    </thead>
                    <tbody>
                      {doc.parameters.map(param => (
                        <tr key={param.name}>
                          <td><code>{param.name}</code></td>
                          <td><code>{param.type}</code></td>
                          <td>{param.required ? 'Yes' : 'No'}</td>
                          <td>{param.description}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </details>
              </td>
            </tr>
          )}
          {doc.messageFormat && (
            <tr>
              <td colSpan={2}>
                <details>
                  <summary>Message Format</summary>
                  <p><strong>Type:</strong> <code>{doc.messageFormat.type}</code></p>
                  <p><strong>Description:</strong> {doc.messageFormat.description}</p>
                  {doc.messageFormat.fields && (
                    <>
                      <h4>Fields</h4>
                      <table>
                        <thead>
                          <tr>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Description</th>
                          </tr>
                        </thead>
                        <tbody>
                          {doc.messageFormat.fields.map(field => (
                            <tr key={field.name}>
                              <td><code>{field.name}</code></td>
                              <td><code>{field.type}</code></td>
                              <td>{field.description}</td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </>
                  )}
                </details>
              </td>
            </tr>
          )}
        </>
      );
    })}
  </tbody>
</table>
