---
sidebar_label: API Reference
---

import SchemaGeneralRaw from '!!raw-loader!../../sdk/vircadia-world-sdk-ts/schema/schema.general.ts';
import ClientCoreRaw from '!!raw-loader!../../sdk/vircadia-world-sdk-ts/module/client/core/vircadia.client.core.ts';

# Vircadia World API Reference

This document provides a comprehensive reference for the Vircadia World API endpoints and communication protocols. This documentation uses raw loaders to ensure the code snippets always reflect the latest implementation.

## Communication Constants

The following constants define the base paths for API communication:

```typescript
// From Communication namespace in schema.general.ts
export const WS_UPGRADE_PATH = "/world/ws";
export const REST_BASE_PATH = "/world/rest";
```

## REST API

The REST API is accessible at the base path defined by `REST_BASE_PATH` (`/world/rest`).

### Available Endpoints

```typescript
// From Communication.REST namespace in schema.general.ts
export enum E_Endpoint {
    AUTH_SESSION_VALIDATE = "AUTH_SESSION_VALIDATE",
}
```

#### Session Validation

```typescript
// From Communication.REST.Endpoint in schema.general.ts
AUTH_SESSION_VALIDATE: {
    path: `${REST_BASE_PATH}/session/validate`,
    method: "POST",
    createRequest: (data: {
        token: string;
        provider: string;
    }): string => JSON.stringify({
        token: data.token,
        provider: data.provider,
    }),
    // Response handlers omitted for brevity
}
```

### SDK Implementation Example

The Vircadia SDK provides a client implementation for authenticating with the server:

```typescript
// From ConnectionManager.connect in vircadia.client.core.ts
async connect(options?: { timeoutMs?: number }): Promise<ConnectionInfo> {
    // If already connected, return immediately
    if (this.isClientConnected()) {
        return this.getConnectionInfo();
    }

    // If connection is in progress, return the existing promise
    if (this.connectionPromise && this.isConnecting()) {
        return this.connectionPromise;
    }

    // Create new connection promise
    this.connectionPromise = (async () => {
        try {
            this.updateConnectionStatus("connecting");

            const url = new URL(this.config.serverUrl);
            url.searchParams.set("token", this.config.authToken);
            url.searchParams.set("provider", this.config.authProvider);

            this.ws = new WebSocket(url);
            this.ws.onmessage = this.handleMessage.bind(this);
            this.ws.onclose = this.handleClose.bind(this);
            this.ws.onerror = this.handleError.bind(this);

            // Connection handling code...
        } catch (error) {
            // Error handling...
        }
    })();

    return this.connectionPromise;
}
```

## WebSocket API

WebSocket connections are established by upgrading a connection at `WS_UPGRADE_PATH` (`/world/ws`).

### Message Types

```typescript
// From Communication.WebSocket namespace in schema.general.ts
export enum MessageType {
    GENERAL_ERROR_RESPONSE = "GENERAL_ERROR_RESPONSE",
    QUERY_REQUEST = "QUERY_REQUEST",
    QUERY_RESPONSE = "QUERY_RESPONSE",
    SYNC_GROUP_UPDATES_RESPONSE = "SYNC_GROUP_UPDATES_RESPONSE",
    TICK_NOTIFICATION = "TICK_NOTIFICATION",
}
```

### Query Implementation

The SDK provides a query method for sending requests to the server:

```typescript
// From ConnectionManager.query in vircadia.client.core.ts
async query<T = unknown>(data: {
    query: string;
    parameters?: unknown[];
    timeoutMs?: number;
}): Promise<Communication.WebSocket.QueryResponseMessage<T>> {
    if (!this.isClientConnected()) {
        throw new Error("Not connected to server");
    }

    const requestId = crypto.randomUUID();
    const message = new Communication.WebSocket.QueryRequestMessage({
        query: data.query,
        parameters: data.parameters,
        requestId,
        errorMessage: null,
    });

    return new Promise<Communication.WebSocket.QueryResponseMessage<T>>(
        (resolve, reject) => {
            const timeout = setTimeout(() => {
                this.pendingRequests.delete(requestId);
                reject(new Error("Request timeout"));
            }, data.timeoutMs ?? 10000);

            this.pendingRequests.set(requestId, {
                resolve: resolve as (value: unknown) => void,
                reject,
                timeout,
            });
            this.ws?.send(JSON.stringify(message));
        },
    );
}
```

### Message Handling

The SDK handles WebSocket messages as follows:

```typescript
// From ConnectionManager.handleMessage in vircadia.client.core.ts
private handleMessage(event: MessageEvent): void {
    try {
        const message = JSON.parse(
            event.data
        ) as Communication.WebSocket.Message;
        const request = this.pendingRequests.get(message.requestId);

        if (request) {
            clearTimeout(request.timeout);
            this.pendingRequests.delete(message.requestId);

            request.resolve(message);
        }
    } catch (error) {
        log({
            message: "Error handling WebSocket message:",
            type: "error",
            error,
            debug: this.config.debug,
            suppress: this.config.suppress,
        });
    }
}
```

## Complete Usage Example

Here's how to use the Vircadia Client Core to connect to a server:

```typescript
import { VircadiaClientCore } from '@vircadia/world-sdk-ts';

// Create client instance
const client = new VircadiaClientCore({
    serverUrl: "wss://your-vircadia-server.com",
    authToken: "your-auth-token",
    authProvider: "your-auth-provider",
    reconnectAttempts: 5,
    reconnectDelay: 5000,
    debug: true,
});

// Add event listeners
client.Utilities.Connection.addEventListener("statusChange", () => {
    const connectionInfo = client.Utilities.Connection.getConnectionInfo();
    console.log("Connection status:", connectionInfo.status);
});

// Connect to server
async function connect() {
    try {
        const connectionInfo = await client.Utilities.Connection.connect();
        console.log("Connected!", connectionInfo);
        
        // Send a query
        const result = await client.Utilities.Connection.query({
            query: "SELECT * FROM entities WHERE id = $1",
            parameters: ["some-entity-id"],
            timeoutMs: 5000
        });
        
        console.log("Query result:", result);
    } catch (error) {
        console.error("Connection error:", error);
    }
}

connect();

// Cleanup when done
function cleanup() {
    client.dispose();
}
```

## Raw Loader Usage Note

This documentation uses raw loaders to import code directly from the source files. In a real implementation, you would set up your documentation build process to use these loaders:

```typescript
// In your MDX file
import SchemaGeneralRaw from '!!raw-loader!../../sdk/vircadia-world-sdk-ts/schema/schema.general.ts';
import ClientCoreRaw from '!!raw-loader!../../sdk/vircadia-world-sdk-ts/module/client/core/vircadia.client.core.ts';

// Then you can display sections or the entire raw code
<CodeBlock language="typescript">{SchemaGeneralRaw}</CodeBlock>

// Or use a custom parser to extract specific sections
<CodeBlock language="typescript">{extractSection(SchemaGeneralRaw, 'Communication.REST')}</CodeBlock>
```

This ensures the documentation always reflects the latest code from the source files. 